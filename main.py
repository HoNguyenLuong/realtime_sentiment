# from fastapi import FastAPI
# from fastapi.middleware.cors import CORSMiddleware
# import threading
# from contextlib import asynccontextmanager
# from src.api.routes import router as api_router
# from src.producer.controller import process_url
# # Import th√™m consumer x·ª≠ l√Ω video
# from src.consumer.spark_video import run as run_video_consumer
# from src.consumer.spark_audio import run as run_audio_consumer
# from src.consumer.spark_comment import run as run_comment_consumer
# import time
#
# # Ph·∫ßn lifespan handler
# @asynccontextmanager
# async def lifespan(app: FastAPI):
#     # T·∫°o v√† kh·ªüi ƒë·ªông thread cho consumer x·ª≠ l√Ω video
#     # video_consumer_thread = threading.Thread(target=run_audio_consumer, daemon=True)
#     # video_consumer_thread.start()
#     # print("Video consumer started in background")
#
#     video_consumer_thread = threading.Thread(target=run_comment_consumer, daemon=True)
#     video_consumer_thread.start()
#     print("Video consumer started in background")
#     #
#     # video_consumer_thread = threading.Thread(target=run_video_consumer, daemon=True)
#     # video_consumer_thread.start()
#     # print("Video consumer started in background")
#     # # Cho consumer th·ªùi gian ƒë·ªÉ kh·ªüi ƒë·ªông ho√†n to√†n
#     time.sleep(5)
#
#     # ‚úÖ Ch·∫°y producer test v·ªõi 1 link c·ª• th·ªÉ
#     test_url = "https://youtu.be/dQ27hrKxSQY?si=_c6N--5cZWZqbiwI"
#     if test_url:  # Ch·ªâ ch·∫°y producer test n·∫øu c√≥ URL
#         threading.Thread(target=process_url, args=(test_url,), daemon=True).start()
#         print(f"Producer test started with URL: {test_url}")
#
#     yield  # ·ª®ng d·ª•ng ch·∫°y ·ªü ƒë√¢y
#
#     # Code ch·∫°y khi t·∫Øt (shutdown)
#     print("Shutting down...")
# # Kh·ªüi t·∫°o app v·ªõi lifespan
# app = FastAPI(lifespan=lifespan)
#
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )
#
# app.include_router(api_router)

# @app.get("/")
# def root():
#     return {"message": "Kafka Video-Audio Streaming API"}

from fastapi import FastAPI, Request, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
import threading
from contextlib import asynccontextmanager
import time
import os
# Import c√°c module c·∫ßn thi·∫øt
from src.api.routes import router as api_router
from src.producer.controller import process_url
from src.producer.config import minio_client, MINIO_BUCKET, FUSION_OBJECT_NAME
from src.consumer.spark_video import run as run_video_consumer
from src.utils.comment_utils import get_sentiment_results as get_comment_sentiment_results
from src.utils.image_utils import get_sentiment_results as get_video_sentiment_results  # ƒê·ªïi t√™n ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n
from src.utils.audio_utils import get_audio_sentiment_results
from src.utils.fusion_utils import get_fusion_sentiment_results, get_fusion_component_results
from src.consumer.spark_audio import run as run_audio_consumer
from src.consumer.spark_comment import run as run_comment_consumer
from src.consumer.fusion_consumer import run as run_fusion_consumer

# Cache k·∫øt qu·∫£ sentiment - v·ªõi c√°c key r√µ r√†ng ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n
sentiment_results = {
    "comment_sentiment": {"positive": 0, "negative": 0, "neutral": 0},
    "video_sentiment": [],
    "audio_sentiment": [],
    "comment_details": [],
    "fusion_sentiment": {}
}
# Ph·∫ßn lifespan handler ƒë·ªÉ kh·ªüi ƒë·ªông background tasks
@asynccontextmanager
async def lifespan(app: FastAPI):
    # T·∫°o v√† kh·ªüi ƒë·ªông thread cho consumer x·ª≠ l√Ω video
    video_consumer_thread = threading.Thread(target=run_video_consumer, daemon=True)
    video_consumer_thread.start()
    print("‚úÖ Video consumer started in background")

    # T·∫°o v√† kh·ªüi ƒë·ªông thread cho consumer x·ª≠ l√Ω audio
    audio_consumer_thread = threading.Thread(target=run_audio_consumer, daemon=True)
    audio_consumer_thread.start()
    print("‚úÖ Audio consumer started in background")

    comment_consumer_thread = threading.Thread(target=run_comment_consumer, daemon=True)
    comment_consumer_thread.start()
    print("‚úÖ Comment consumer started in background")

    fusion_consumer_thread = threading.Thread(target=run_fusion_consumer, daemon=True)
    fusion_consumer_thread.start()
    print("‚úÖ Fusion consumer started in background")

    # Cho consumer th·ªùi gian ƒë·ªÉ kh·ªüi ƒë·ªông ho√†n to√†n
    time.sleep(5)

    yield  # ·ª®ng d·ª•ng ch·∫°y ·ªü ƒë√¢y

    # Code ch·∫°y khi t·∫Øt (shutdown)
    print("üõë Shutting down...")

# Kh·ªüi t·∫°o app v·ªõi lifespan
app = FastAPI(lifespan=lifespan)

# Templates config
templates = Jinja2Templates(directory="templates")
# Th√™m h√†m get_flashed_messages gi·∫£ v√†o context
templates.env.globals["get_flashed_messages"] = lambda: []

# N·∫øu c√≥ th∆∞ m·ª•c static, mount n√≥
if os.path.exists("static"):
    app.mount("/static", StaticFiles(directory="static"), name="static")

# C·∫•u h√¨nh CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Th√™m API routes t·ª´ module kh√°c
app.include_router(api_router)

def prepare_sentiment_data(result):
    """
    Chu·∫©n b·ªã d·ªØ li·ªáu sentiment ƒë·ªÉ hi·ªÉn th·ªã an to√†n
    """
    if result is None:
        return {"positive": 0, "negative": 0, "neutral": 0, "status": "processing", "total": 0}

    # ƒê·∫£m b·∫£o c√°c key sentiment lu√¥n t·ªìn t·∫°i
    if "positive" not in result:
        result["positive"] = 0
    if "negative" not in result:
        result["negative"] = 0
    if "neutral" not in result:
        result["neutral"] = 0

    # ƒê·∫£m b·∫£o c√°c gi√° tr·ªã l√† s·ªë
    result["positive"] = int(result["positive"]) if result["positive"] is not None else 0
    result["negative"] = int(result["negative"]) if result["negative"] is not None else 0
    result["neutral"] = int(result["neutral"]) if result["neutral"] is not None else 0

    # T√≠nh t·ªïng
    result["total"] = result["positive"] + result["negative"] + result["neutral"]

    return result
@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    """Trang ch·ªß"""
    return templates.TemplateResponse("index.html", {
        "request": request,
        "result": None,
        "youtube_url": "",
        "messages": []  # Th√™m messages tr·ªëng ƒë·ªÉ thay th·∫ø flash messages
    })

@app.post("/", response_class=HTMLResponse)
async def process_youtube(request: Request, youtube_url: str = Form(...)):
    """X·ª≠ l√Ω URL YouTube v√† hi·ªÉn th·ªã k·∫øt qu·∫£ tr√™n giao di·ªán"""
    messages = []  # Danh s√°ch th√¥ng b√°o ƒë·ªÉ thay th·∫ø flash messages

    if not youtube_url:
        messages.append({"category": "warning", "message": "Vui l√≤ng cung c·∫•p URL YouTube h·ª£p l·ªá"})
        return templates.TemplateResponse("index.html", {
            "request": request,
            "error": "Vui l√≤ng cung c·∫•p URL YouTube h·ª£p l·ªá",
            "youtube_url": "",
            "messages": messages
        })

    try:
        # G·ªçi h√†m process_url ƒë·ªÉ x·ª≠ l√Ω URL t·ª´ producer
        result = process_url(youtube_url)
        messages.append({"category": "success", "message": "X·ª≠ l√Ω URL th√†nh c√¥ng!"})

        # Chu·∫©n b·ªã v√† cache k·∫øt qu·∫£ comment sentiment
        processed_result = prepare_sentiment_data(result)
        sentiment_results["comment_sentiment"] = processed_result

        # Tr·∫£ v·ªÅ template v·ªõi k·∫øt qu·∫£
        return templates.TemplateResponse("index.html", {
            "request": request,
            "result": processed_result,
            "youtube_url": youtube_url,
            "messages": messages
        })
    except Exception as e:
        messages.append({"category": "danger", "message": f"L·ªói x·ª≠ l√Ω URL: {str(e)}"})
        return templates.TemplateResponse("index.html", {
            "request": request,
            "error": f"L·ªói x·ª≠ l√Ω URL: {str(e)}",
            "youtube_url": youtube_url,
            "messages": messages
        })

@app.get("/api/get_results")
async def get_results():
    """API endpoint ƒë·ªÉ l·∫•y k·∫øt qu·∫£ sentiment m·ªõi nh·∫•t c·ªßa comments"""
    try:
        # Tr·∫£ v·ªÅ k·∫øt qu·∫£ t·ª´ cache
        return sentiment_results["comment_sentiment"]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/get_video_sentiments")
async def get_video_sentiments():
    try:
        results = get_video_sentiment_results("emotion_results")

        # Explicitly convert results to JSON-serializable format
        json_safe_results = []
        for frame in results:
            json_safe_frame = {
                "frame_id": frame.get("frame_id", 0),
                "video_id": frame.get("video_id", ""),
                "num_faces": int(frame.get("num_faces", 0)),
                "emotions": frame.get("emotions", {}),
                "processed_at": frame.get("processed_at", "")
            }
            json_safe_results.append(json_safe_frame)

        sentiment_results["video_sentiment"] = json_safe_results
        return json_safe_results
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/get_audio_sentiments")
async def get_audio_sentiments(video_id: str = None):
    """API endpoint ƒë·ªÉ l·∫•y k·∫øt qu·∫£ ph√¢n t√≠ch c·∫£m x√∫c t·ª´ audio"""
    try:
        # L·∫•y k·∫øt qu·∫£ sentiment t·ª´ audio s·ª≠ d·ª•ng h√†m t·ª´ utils
        results = get_audio_sentiment_results("audio_results")

        # L·ªçc k·∫øt qu·∫£ theo video_id n·∫øu ƒë∆∞·ª£c cung c·∫•p
        if video_id:
            results = [r for r in results if r.get("video_id") == video_id]

        # S·∫Øp x·∫øp l·∫°i k·∫øt qu·∫£ theo th·ªùi gian x·ª≠ l√Ω (m·ªõi nh·∫•t tr∆∞·ªõc)
        results.sort(key=lambda x: x.get("processed_at", ""), reverse=True)

        # Cache k·∫øt qu·∫£
        sentiment_results["audio_sentiment"] = results

        return results
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/video_emotions", response_class=HTMLResponse)
async def video_emotions_page(request: Request):
    """Trang hi·ªÉn th·ªã ph√¢n t√≠ch c·∫£m x√∫c t·ª´ frames video"""
    try:
        # L·∫•y k·∫øt qu·∫£ t·ª´ cache ho·∫∑c g·ªçi l·∫°i h√†m
        if not sentiment_results["video_sentiment"]:
            results = get_video_sentiment_results("emotion_results")
            sentiment_results["video_sentiment"] = results
        else:
            results = sentiment_results["video_sentiment"]

        return templates.TemplateResponse("video_emotions.html", {
            "request": request,
            "results": results,
            "messages": []  # Th√™m messages tr·ªëng
        })
    except Exception as e:
        # Redirect v·ªÅ trang ch·ªß v·ªõi th√¥ng b√°o l·ªói
        return RedirectResponse(url="/", status_code=303)

@app.get("/audio_emotions", response_class=HTMLResponse)
async def audio_emotions_page(request: Request):
    """Trang hi·ªÉn th·ªã ph√¢n t√≠ch c·∫£m x√∫c t·ª´ audio"""
    try:
        # L·∫•y k·∫øt qu·∫£ t·ª´ cache ho·∫∑c g·ªçi l·∫°i h√†m
        if not sentiment_results["audio_sentiment"]:
            results = get_audio_sentiment_results("audio_results")
            sentiment_results["audio_sentiment"] = results
        else:
            results = sentiment_results["audio_sentiment"]

        return templates.TemplateResponse("audio_emotions.html", {
            "request": request,
            "results": results,
            "messages": []  # Th√™m messages tr·ªëng
        })
    except Exception as e:
        messages = [{"category": "danger", "message": f"L·ªói khi t·∫£i d·ªØ li·ªáu audio: {str(e)}"}]
        # Redirect v·ªÅ trang ch·ªß v·ªõi th√¥ng b√°o l·ªói
        return RedirectResponse(url="/", status_code=303)

# API endpoint b·ªï sung ƒë·ªÉ debug
@app.get("/api/status")
async def status():
    """Endpoint ki·ªÉm tra tr·∫°ng th√°i c·ªßa h·ªá th·ªëng"""
    return {
        "status": "running",
        "comments_analyzed": sum(sentiment_results["comment_sentiment"].values()) if sentiment_results["comment_sentiment"] else 0,
        "video_frames_analyzed": len(sentiment_results["video_sentiment"]),
        "audio_chunks_analyzed": len(sentiment_results["audio_sentiment"]),  # Th√™m s·ªë l∆∞·ª£ng audio chunks
    }

@app.get("/api/get_comment_sentiments")
async def get_comment_sentiments(video_id: str = None):
    """API endpoint ƒë·ªÉ l·∫•y k·∫øt qu·∫£ ph√¢n t√≠ch c·∫£m x√∫c t·ª´ comments"""
    try:
        # L·∫•y k·∫øt qu·∫£ sentiment t·ª´ comments s·ª≠ d·ª•ng h√†m t·ª´ utils
        results = get_comment_sentiment_results("comment_sentiment_results")

        # L·ªçc k·∫øt qu·∫£ theo video_id n·∫øu ƒë∆∞·ª£c cung c·∫•p
        if video_id:
            results = [r for r in results if r.get("content_id") == video_id]

        # C·∫≠p nh·∫≠t cache cho k·∫øt qu·∫£ comment sentiment
        comment_sentiment_summary = {"positive": 0, "negative": 0, "neutral": 0}
        languages_detected = {}

        for result in results:
            sentiment = result.get("sentiment", "neutral")
            if sentiment in comment_sentiment_summary:
                comment_sentiment_summary[sentiment] += 1

            # Ghi nh·∫≠n ng√¥n ng·ªØ
            language = result.get("language", "unknown")
            if language in languages_detected:
                languages_detected[language] += 1
            else:
                languages_detected[language] = 1

        # C·∫≠p nh·∫≠t cache v·ªõi k·∫øt qu·∫£ t·ªïng h·ª£p
        sentiment_results["comment_sentiment"] = {
            **comment_sentiment_summary,
            "total": len(results),
            "languages": languages_detected
        }

        return results
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/comment_sentiment", response_class=HTMLResponse)
async def comment_sentiment_page(request: Request, video_id: str = None):
    """Trang hi·ªÉn th·ªã ph√¢n t√≠ch c·∫£m x√∫c t·ª´ comments"""
    try:
        # L·∫•y k·∫øt qu·∫£ sentiment t·ª´ comments
        results = get_comment_sentiment_results("comment_sentiment_results")

        # L·ªçc theo video_id n·∫øu c√≥
        if video_id:
            filtered_results = [r for r in results if r.get("content_id") == video_id]
        else:
            filtered_results = results

        # T·∫°o t·ªïng h·ª£p theo sentiment
        summary = {"positive": 0, "negative": 0, "neutral": 0}
        languages = {}

        for result in filtered_results:
            sentiment = result.get("sentiment", "neutral")
            if sentiment in summary:
                summary[sentiment] += 1

            # Ghi nh·∫≠n ng√¥n ng·ªØ
            language = result.get("language", "unknown")
            if language in languages:
                languages[language] += 1
            else:
                languages[language] = 1

        # C·∫≠p nh·∫≠t cache
        sentiment_results["comment_sentiment"] = {
            **summary,
            "total": len(filtered_results),
            "languages": languages
        }

        return templates.TemplateResponse("comment_sentiment.html", {
            "request": request,
            "results": filtered_results,
            "summary": summary,
            "languages": languages,
            "video_id": video_id,
            "total_comments": len(filtered_results),
            "messages": []
        })
    except Exception as e:
        messages = [{"category": "danger", "message": f"L·ªói khi t·∫£i d·ªØ li·ªáu comments: {str(e)}"}]
        return templates.TemplateResponse("comment_sentiment.html", {
            "request": request,
            "results": [],
            "summary": {"positive": 0, "negative": 0, "neutral": 0},
            "languages": {},
            "video_id": video_id,
            "total_comments": 0,
            "messages": messages
        })

@app.get("/fusion_sentiment", response_class=HTMLResponse)
async def fusion_sentiment_page(request: Request):
    """Trang hi·ªÉn th·ªã k·∫øt qu·∫£ ph√¢n t√≠ch c·∫£m x√∫c t·ªïng h·ª£p (fusion)"""
    try:
        # Get video_id from query parameters if available
        video_id = request.query_params.get('video_id')

        # Create a cache key based on video_id if available
        cache_key = f"fusion_sentiment_{video_id}" if video_id else "fusion_sentiment"

        # Ki·ªÉm tra xem ƒë√£ c√≥ k·∫øt qu·∫£ fusion trong cache ch∆∞a
        if cache_key not in sentiment_results:
            # N·∫øu ch∆∞a, th·ª≠ l·∫•y t·ª´ fusion utils
            result = get_fusion_sentiment_results(video_id=video_id)
            if result:
                sentiment_results[cache_key] = result
            else:
                # N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£, hi·ªÉn th·ªã th√¥ng b√°o ƒëang x·ª≠ l√Ω
                video_msg = f" cho video ID: {video_id}" if video_id else ""
                messages = [{"category": "info",
                             "message": f"ƒêang x·ª≠ l√Ω ph√¢n t√≠ch c·∫£m x√∫c t·ªïng h·ª£p{video_msg}. Trang s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t khi c√≥ k·∫øt qu·∫£."}]
                return templates.TemplateResponse("fusion_sentiment.html", {
                    "request": request,
                    "result": {},
                    "video_id": video_id,  # Pass video_id to template
                    "auto_refresh": True,  # Th√™m flag ƒë·ªÉ template bi·∫øt c·∫ßn auto-refresh
                    "messages": messages
                })

        # L·∫•y th√™m k·∫øt qu·∫£ th√†nh ph·∫ßn n·∫øu c√≥ template hi·ªÉn th·ªã chi ti·∫øt
        component_results = None
        try:
            # If your get_fusion_component_results doesn't yet support video_id,
            # you might need to modify that function too
            component_results = get_fusion_component_results(video_id=video_id)
        except Exception:
            pass  # B·ªè qua l·ªói khi kh√¥ng l·∫•y ƒë∆∞·ª£c k·∫øt qu·∫£ th√†nh ph·∫ßn

        return templates.TemplateResponse("fusion_sentiment.html", {
            "request": request,
            "result": sentiment_results[cache_key],
            "components": component_results,
            "video_id": video_id,  # Pass video_id to template
            "auto_refresh": False,  # Kh√¥ng c·∫ßn auto-refresh n·ªØa v√¨ ƒë√£ c√≥ k·∫øt qu·∫£
            "messages": []
        })
    except Exception as e:
        video_id = request.query_params.get('video_id')
        video_msg = f" cho video ID: {video_id}" if video_id else ""
        messages = [{"category": "danger", "message": f"L·ªói khi t·∫£i d·ªØ li·ªáu fusion{video_msg}: {str(e)}"}]
        return templates.TemplateResponse("fusion_sentiment.html", {
            "request": request,
            "result": {},
            "video_id": video_id,  # Pass video_id to template
            "auto_refresh": True,  # V·∫´n c·∫ßn auto-refresh ƒë·ªÉ th·ª≠ l·∫°i
            "messages": messages
        })
# Run uvicorn server
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)